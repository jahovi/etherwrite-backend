import CouchDbService from "../couch/couch-db.service";
import ChangesetService from "../changeset-service/changeset-service";
import { MiniMapScrollPos } from "./minimapscrollpos.type";
import { StructuredTrackingData } from "./structured-tracking-data-type";
import { TrackingData } from "./trackingdata-type";
import AuthorRegistry from "../authors/author-registry";

/**
 * Collects and processes data from the tracking-entries in couch
 * db generated by the ep_tracking plugin. An instance of this class
 * is assigned to each pad. The creation of instances is handled in
 * the PadRegistry-class.
 */
export default class TrackingService {

	/** Stores the instances of this class under the corresponding pad names*/
	public static instanceRegistry: Record<string, TrackingService> = {};
	private static docScope = CouchDbService.getConnection("etherpad");

	/**The timestamp of the latest db entry that was read */
	private static latestTimestamp = 0;

	/**Indicates whether there were new entries for that specific pad found */
	private updateRequired = true;

	/** The amount of milliseconds that passes, before a general update of data occurs*/
	private static updateDelay = Number(process.env.TRS_UPDATE_DELAY) || 5000;

	/** The name of the pad, for which this instance provides services*/
	public readonly pad: string;

	/** Contains the raw data from couch db for the corresponding pad*/
	private padData: TrackingData[] = [];

	/**For each encountered user this contains a StructuredTrackingData object */
	private structuredTrackingData: Record<string, StructuredTrackingData> = {};

	/** Can be accessed by routers to deliver the most recent information regarding scroll positions */
	public miniMapScrollPositions: MiniMapScrollPos = {};

	constructor(pad: string) {
		TrackingService.instanceRegistry[pad] = this;
		this.pad = pad;
	}

	/**
	 * Makes the all instances of TrackingService regularly
	 * update their data from couch db.
	 */
	public static async initAndUpdate() {
		await TrackingService.getAndDistributeDatabaseEntries();
		Object.keys(TrackingService.instanceRegistry).forEach(padName => {
			if (TrackingService.instanceRegistry[padName].updateRequired) {
				TrackingService.instanceRegistry[padName].generateMiniMapScrollPositions();
				TrackingService.instanceRegistry[padName].updateRequired = false;
			}
		});
		setTimeout(() => TrackingService.initAndUpdate(), TrackingService.updateDelay);
	}

	/**
	 * Extracts the most recent information regarding the
	 * scroll position of each author and stores it into
	 * 'this.miniMapScrollPositions'. If an author is assumed to be
	 * disconnected, no scroll data will be stored for this author.
	 */
	private generateMiniMapScrollPositions() {

		this.buildStructuredPadData();
		const data = this.structuredTrackingData;
		const out: MiniMapScrollPos = {};
		Object.entries(data).forEach(([author, dataEntry]) => {
			if (!(dataEntry.lastDisconnected?.time && dataEntry.lastConnected?.time
				&& dataEntry.lastDisconnected.time > dataEntry.lastConnected.time)) {
				// user is NOT disconnected
				if (dataEntry.lastTabScrolling != undefined) {
					if (dataEntry.lastDisconnected == undefined || (dataEntry.lastTabScrolling.time > dataEntry.lastDisconnected.time)) {
						// last scrolling event data should be newer than last disconnect event
						out[author] = {
							timeStamp: dataEntry.lastTabScrolling.time,
							debugTimeStamp: new Date(dataEntry.lastTabScrolling.time).toString(),
							topIndex: dataEntry.lastTabScrolling.state.top.index,
							bottomIndex: dataEntry.lastTabScrolling.state.bottom.index,
						};
					} else {
						// console.log(dataEntry.lastTabScrolling.time + " < " + dataEntry.lastDisconnected.time);
					}
				} else {
					// console.log("no tab scroll detected");
				}
			} else {
				// console.log(author+" not connected");
			}
		});
		this.miniMapScrollPositions = out;
		console.log(out);
	}


	/**Filters through the padData and creates an object for
	 * each author in this pad. Each of these objects contains
	 * a set of the most recent tracking entries for this author
	 * in several categories.
	 * See the definition of StructuredTrackingData for details.
	 * Each StructuredTrackingData object is then stored inside
	 * the return object under the key of the author id.
	 * @returns an object as described above
	 */
	private buildStructuredPadData() {
		const data = this.padData;
		const strData = this.structuredTrackingData;
		const csp = ChangesetService.instanceRegistry[this.pad];
		if (!data || !data.length || !csp) {
			return strData;
		}

		data.forEach(entry => {
			if (!strData[entry.user]) {
				strData[entry.user] = {};
			}

			const userdata = strData[entry.user];
			userdata.lastCHSActive = csp.lastActivityTimeStamp[entry.user];
			userdata.lastCHSActiveDebug = new Date(userdata.lastCHSActive).toString();
			switch (entry.type) {
			case (0): {
				if (!userdata.lastConnected) {
					userdata.lastConnected = entry;
				} else {
					if (userdata.lastConnected.time < entry.time) {
						userdata.lastConnected = entry;
					}
				}
				break;
			}
			case (4): {
				if (!userdata.lastDisconnected) {
					userdata.lastDisconnected = entry;
				} else {
					if (userdata.lastDisconnected.time < entry.time) {
						userdata.lastDisconnected = entry;
					}
				}
				break;
			}
			case (3): {
				if (!userdata.lastTabVisible) {
					userdata.lastTabVisible = entry;
				} else {
					if (userdata.lastTabVisible.time < entry.time) {
						userdata.lastTabVisible = entry;
					}
				}
				break;
			}
			case (5): {
				if (!userdata.lastTabScrolling) {
					userdata.lastTabScrolling = entry;
				} else {
					if (userdata.lastTabScrolling.time < entry.time) {
						userdata.lastTabScrolling = entry;
					}
				}
				break;
			}
			}
		});
		this.structuredTrackingData = strData;
	}

	/**
	 * Collects all available tracking files in couch db
	 * and distributes each of them to the corresponding
	 * instance of TrackingService, if the timestamp of
	 * those tracking files is newer. The data will be stored
	 * in the padData property of the instances.
	 */
	private static async getAndDistributeDatabaseEntries() {
		const data = await CouchDbService.readView(TrackingService.docScope, "evahelpers", "fetchtrackingdata",
			{ start_key: "tracking:" + (TrackingService.latestTimestamp + 1) });
		const storage: Record<string, TrackingData[]> = {};
		Object.keys(TrackingService.instanceRegistry).forEach(padName => {
			storage[padName] = [];
		});
		let maxTimestamp = 0;
		data.rows.forEach(doc => {
			const content = doc.value as TrackingData;
			AuthorRegistry.put(content.user);

			if (!content.time) {
				let timeStampPart = doc.key.substring(9);
				timeStampPart = timeStampPart.substring(0, timeStampPart.indexOf(":"));
				content.time = Number(timeStampPart);
			}
			const date = new Date(0);
			date.setUTCMilliseconds(content.time);
			content.debugtime = date.toString();
			maxTimestamp = content.time > maxTimestamp ? content.time : maxTimestamp;
			if (storage[content.pad]) {
				storage[content.pad].push(content);
			}
		});
		if (maxTimestamp > TrackingService.latestTimestamp) {
			TrackingService.latestTimestamp = maxTimestamp;
		}
		Object.keys(storage).forEach(padName => {
			if (storage[padName].length > 0) {
				TrackingService.instanceRegistry[padName].padData = storage[padName];
				TrackingService.instanceRegistry[padName].updateRequired = true;
			}
		})
	}

}