import CouchDbService from "../couch/couch-db.service";
import ChangesetService from "../changeset-service/changeset-service";
import {MiniMapScrollPos} from "./minimapscrollpos.type";
import {StructuredTrackingData} from "./structured-tracking-data-type";
import {TrackingData} from "./trackingdata-type";
import AuthorRegistry from "../authors/author-registry";

/**
 * Collects and processes data from the tracking-entries in couch
 * db generated by the ep_tracking plugin. An instance of this class
 * is assigned to each pad. The creation of instances is handled in
 * the PadRegistry-class.
 */
export default class TrackingService {

	/** Stores the instances of this class under the corresponding pad names*/
	public static instanceRegistry: Record<string, TrackingService> = {};
	private static docScope = CouchDbService.getConnection("etherpad");

	/* The amount of milliseconds that passes, before a general update of data occurs*/
	private static updateDelay = Number(process.env.TRS_UPDATE_DELAY) || 5000;

	/* The name of the pad, for which this instance provides services*/
	public readonly pad: string;

	/* Contains the raw data from couch db for the corresponding pad*/
	private padData: TrackingData[] = [];

	/** Can be accessed by routers to deliver the most recent information regarding scroll positions */
	public miniMapScrollPositions: MiniMapScrollPos = {};

	constructor(pad: string) {
		TrackingService.instanceRegistry[pad] = this;
		this.pad = pad;
	}

	/**
	 * Makes the all instances of TrackingService regularly
	 * update their data from couch db.
	 */
	public static async initAndUpdate() {
		await TrackingService.getAndDistributeDatabaseEntries();
		Object.keys(TrackingService.instanceRegistry).forEach(padName => {
			TrackingService.instanceRegistry[padName].generateMiniMapScrollPositions();
		});
		setTimeout(() => TrackingService.initAndUpdate(), TrackingService.updateDelay);
	}

	/**
	 * Extracts the most recent information regarding the
	 * scroll position of each author and stores it into
	 * 'this.miniMapScrollPositions'. If an author is assumed to be
	 * disconnected, no scroll data will be stored for this author.
	 */
	private generateMiniMapScrollPositions() {
		const data = this.getStructuredPadData();
		const out: MiniMapScrollPos = {};

		Object.entries(data).forEach(([author, dataEntry]) => {

			if (!(dataEntry.lastDisconnected?.time && dataEntry.lastConnected?.time
				&& dataEntry.lastDisconnected.time > dataEntry.lastConnected.time)) {
				// user is NOT disconnected

				if (dataEntry.lastTabScrolling != undefined) {


					if (dataEntry.lastDisconnected == undefined || (dataEntry.lastTabScrolling.time > dataEntry.lastDisconnected.time)) {
						// last scrolling event data should be newer than last disconnect event
						out[author] = {
							timeStamp: dataEntry.lastTabScrolling.time,
							debugTimeStamp: new Date(dataEntry.lastTabScrolling.time).toString(),
							topIndex: dataEntry.lastTabScrolling.state.top.index,
							bottomIndex: dataEntry.lastTabScrolling.state.bottom.index,
						};
					}
				}
			}
		});
		this.miniMapScrollPositions = out;
	}


	/**Filters through the padData and creates an object for
	 * each author in this pad. Each of these objects contains
	 * a set of the most recent tracking entries for this author
	 * in several categories.
	 * See the definition of StructuredTrackingData for details.
	 * Each StructuredTrackingData object is then stored inside
	 * the return object under the key of the author id.
	 * @returns an object as described above
	 */
	private getStructuredPadData() {
		const data = this.padData;
		const out: Record<string, StructuredTrackingData> = {};
		const csp = ChangesetService.instanceRegistry[this.pad];
		if (!data || !data.length || !csp) {
			return out;
		}

		data.forEach(entry => {
			if (!out[entry.user]) {
				out[entry.user] = {};
			}

			const userdata = out[entry.user];
			userdata.lastCHSActive = csp.lastActivityTimeStamp[entry.user];
			userdata.lastCHSActiveDebug = new Date(userdata.lastCHSActive).toString();
			switch (entry.type) {
			case (0): {
				if (!userdata.lastConnected) {
					userdata.lastConnected = entry;
				} else {
					if (userdata.lastConnected.time < entry.time) {
						userdata.lastConnected = entry;
					}
				}
				break;
			}
			case (4): {
				if (!userdata.lastDisconnected) {
					userdata.lastDisconnected = entry;
				} else {
					if (userdata.lastDisconnected.time < entry.time) {
						userdata.lastDisconnected = entry;
					}
				}
				break;
			}
			case (3): {
				if (!userdata.lastTabVisible) {
					userdata.lastTabVisible = entry;
				} else {
					if (userdata.lastTabVisible.time < entry.time) {
						userdata.lastTabVisible = entry;
					}
				}
				break;
			}
			case (5): {
				if (!userdata.lastTabScrolling) {
					userdata.lastTabScrolling = entry;
				} else {
					if (userdata.lastTabScrolling.time < entry.time) {
						userdata.lastTabScrolling = entry;
					}
				}
				break;
			}
			}
		});
		return out;
	}

	/**
	 * Collects all available tracking files in couch db
	 * and distributes each of them to the corresponding
	 * instance of TrackingService. The data will be stored
	 * in the padData property of the instances.
	 */
	private static async getAndDistributeDatabaseEntries() {
		const data = await CouchDbService.readView(TrackingService.docScope, "evahelpers", "fetchtrackingdata");
		const storage: Record<string, TrackingData[]> = {};
		Object.keys(TrackingService.instanceRegistry).forEach(padName => {
			storage[padName] = [];
		});
		const authorsList: string[] = [];
		data.rows.forEach(doc => {
			const content = doc.value as TrackingData;

			if (!authorsList.includes(content.user)) {
				AuthorRegistry.put(content.user);
				authorsList.push(content.user);
			}

			/* Unfortunately ep-tracking doesnÂ´t seem to initialise the
			time property that is announced in the ep-tracking-readme.
			Therefore this will have to be reconstructed here by parsing
			that specific part from the document key*/
			if (!content.time) {
				let timeStampPart = doc.key.substring(28, doc.key.length);
				timeStampPart = timeStampPart.substring(0, timeStampPart.indexOf(":"));
				content.time = Number(timeStampPart);
			}
			const date = new Date(0);
			date.setUTCMilliseconds(content.time);
			content.debugtime = date.toString();

			if (storage[content.pad]) {
				storage[content.pad].push(content);
			}
		});
		Object.keys(storage).forEach(padName => {
			TrackingService.instanceRegistry[padName].padData = storage[padName];
		})
	}

}